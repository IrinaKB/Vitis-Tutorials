<table class="sphinxhide">
 <tr>
   <td align="center"><img src="https://www.xilinx.com/content/dam/xilinx/imgs/press/media-kits/corporate/xilinx-logo.png" width="30%"/><h1>2020.1 Vitis™ アプリケーション アクセラレーション開発フロー チュートリアル</h1><a href="https://github.com/Xilinx/Vitis-Tutorials/branches/all">2019.2 Vitis アプリケーション アクセラレーション開発フロー チュートリアル</a></td>
 </tr>
 <tr>
 <td>
 </td>
 </tr>
</table>

# RTL カーネル入門

## チュートリアルの概要

特定のソフトウェアおよびハードウェア インターフェイス要件を満たす RTL デザインは、ザイリンクス オブジェクト (`.xo`) ファイルにパッケージできます。このファイルをバイナリ コンテナーにリンクすると、ホスト アプリケーションがカーネルを FPGA にプログラムする際に使用する `xclbin` ファイルを作成できます。

このチュートリアルには、次のリファレンスファイルが含まれます。

- `B[i] = A[i]+B[i]` 演算を実行する単純なベクター累算の例。

- ホスト アプリケーション (カーネルとの通信には OpenCL API を使用):

  - ホストが読み出し/書き込みバッファーを作成し、ホストと FPGA 間のデータを転送します。
  - ホストが RTL カーネルをエンキュー (FPGA で実行) します。DDR のバッファーが読み込まれ、`B[i] = A[i]+B[i]` が実行され、結果が DDR に書き込まれます。
  - ホストがデータを読み出し、結果を比較します。

これらのリファレンス ファイルを使用して、Vitis™ IDE プロジェクトを作成する最初の手順から、プロジェクトをビルドして実行する最後の手順まで説明します。

## 開始前の確認事項

このチュートリアルでは、次を使用します。

* BASH Linux シェル コマンド
* 2020.1 Vitis コア開発キット リリースおよび xilinx\_u200\_xdma\_201830\_2 プラットフォーム。必要であれば、ほかのバージョンおよびプラットフォームを使用するように変更することもできます。

> **重要:**
>
> * 例を実行する前に、[インストール](https://japan.xilinx.com/html_docs/xilinx2019_2/vitis_doc/vhc1571429852245.html)の手順に従って Vitis コア開発キットをインストールしておく必要があります。
> * ザイリンクス Alveo™ データセンター アクセラレータ カードでアプリケーションを実行する場合は、[Alveo ポートフォリオ](https://japan.xilinx.com/products/boards-and-kits/alveo.html) ページの手順に従って、カードとソフトウェア ドライバーを正しくインストールしてください。

### チュートリアル リファレンス ファイルの入手

1. リファレンス ファイルを入手するには、ターミナルに `git clone https://github.com/Xilinx/Vitis-Tutorials` と入力します。
2. `getting-started-rtl-kernels` ディレクトリに移動し、`reference-files` ディレクトリにアクセスします。

## RTL カーネルとして RTL デザインを使用するための要件

Vitis IDE 内で RTL カーネルを使用するには、『Vitis 統合ソフトウェア プラットフォームの資料』 (UG1416) のアプリケーション アクセラレーション開発フローの [RTL カーネル](https://japan.xilinx.com/cgi-bin/docs/rdoc?v=2020.1;t=vitis+doc;d=devrtlkernel.html)に記述されている Vitis コア開発キット実行モデルおよびハードウェア インターフェイス要件を満たす必要があります。

### カーネルの実行モデル

RTL カーネルは、C/C++ カーネルと同じソフトウェア インターフェイスおよび実行モデルを使用します。ホスト アプリケーションでは、RTL カーネルは void 戻り値、スカラー引数、およびポインター引数を持つ関数として認識されます。次に例を示します。

```
void vadd_A_B(int *a, int *b, int scalar)
```

この例からは、RTL カーネルの実行モデルがソフトウェア関数のものと類似していることがわかります。

- 呼び出されたときに開始。
- データを処理して必要な結果を生成。
- 処理が終了したら、通知を送信。

具体的には、Vitis コア開発キット実行モデルは次を前提としています。

- スカラー引数は AXI4-Lite スレーブ インターフェイスを介してカーネルに渡されます。
- ポインター引数はグローバル メモリ (DDR、HBM または PLRAM) を介して転送されます。
- ポインター引数のベース アドレスは、その AXI4-Lite スレーブ インターフェイスを介してカーネルに渡されます。
- カーネルは、1 つまたは複数の AXI4 マスター インターフェイスを介してグローバル メモリ内のポインター引数にアクセスします。
- カーネルは、AXI4-Lite インターフェイスを介してホスト アプリケーションにより開始されます。
- カーネルは、演算が終了したら、AXI4-Lite インターフェイスまたは特別な割り込み信号を介してホスト アプリケーションに通知する必要があります。

### ハードウェア インターフェイス要件

この実行モデルを使用するには、カーネルが次のハードウェア インターフェイス要件を満たしている必要があります。

- プログラマブル レジスタ (制御レジスタ、スカラー引数、およびポインターのベース アドレス) へのアクセスに使用するインターフェイスは AXI4-Lite スレーブ インターフェイス 1 つのみ。

  - オフセット `0x00` - 制御レジスタ: カーネル ステータスを制御および表示します。
    - ビット `0`: **start** 信号: カーネルがデータ処理を開始できるようになるとホスト アプリケーションによりアサートされます。**done** 信号がアサートされたときにクリアされる必要があります。
    - ビット `1`: **done** 信号: カーネルが演算を完了するとアサートされます。読み出しでクリアされます。
    - ビット `2`: **idle** 信号: データが処理されていないときにアサートされます。**done** 信号がアサートされると同時に Low から High に遷移する必要があります。
  - オフセット `0x04` - グローバル割り込みイネーブル レジスタ: ホストへの割り込みをイネーブルにします。
  - オフセット `0x08` - IP 割り込みイネーブル レジスタ: 割り込みを生成するのに IP で生成されたどの信号を使用するかを指定します。
  - オフセット `0x0C`- IP 割り込みステータス レジスタ: 割り込みステータスを示します。
  - オフセット `0x10` およびそれ以降 - カーネル引数レジスタ: スカラー パラメーターおよびポインターのベース アドレス用のレジスタ。

- 次のインターフェイスの 1 つまたは複数:

  - グローバル メモリと通信するための AXI4 マスター インターフェイス。
    - AXI4 マスター インターフェイスにはすべて 64 ビット アドレスが必要です。
    - グローバル メモリ空間の分割はカーネル開発者が実行します。グローバル メモリの各パーティションがカーネル引数になります。各パーティションのベース アドレス (メモリ オフセット) は、AXI4-Lite スレーブ インターフェイスを介してプログラム可能な制御レジスタにより設定されます。
    - AXI4 マスターには WRAP または FIXED タイプのバースト、またはサイズが満たない (サブサイズ) バーストは使用できないので、AxSIZE は AXI データ バスの幅と同じである必要があります。
    - 上記の要件を満たさないユーザー ロジックまたは RTL コードは、ラップまたはブリッジする必要があります。
  - その他のカーネルとの通信用の AXI4-Stream インターフェイス。

変更前の RTL デザインが別の実行モデルまたはハードウェア インターフェイスを使用する場合、デザインが正しく動作し、インターフェイス要件に従うよう、ロジックを追加する必要があります。

### Vector-Accumulate RTL IP

`B[i]=A[i]+B[i]` を実行する Vector-Accumulate RTL IP は、上記の要件すべてを満たしており、次のような特性を持っています。

- 2 つの AXI4 メモリ マップド インターフェイス:
  - A を読み出すインターフェイス
  - B を読み出して書き込むインターフェイス
  - このデザインで使用される AXI4 マスターは、WRAP、FIXED、または NARROW バースト タイプを使用しません。
- 1 つの AXI4-Lite スレーブ制御インターフェイス:
  - 制御レジスタはオフセット `0x00`
  - カーネル引数レジスタをオフセット `0x10` にすると、ホストがスカラー値をカーネルに渡すことができます。
  - カーネル引数レジスタをオフセット `0x18` にすると、ホストがグローバル メモリの A のベース アドレスをカーネルに渡すことができます。
  - カーネル引数レジスタをオフセット `0x24` にすると、ホストがグローバル メモリの B のベース アドレスをカーネルに渡すことができます。

これらの要件は、既存の RTL モジュールから独自の RTL カーネルを作成する場合の基本となり、また RTL Kernel ウィザードへの入力として使用されます。

## 次の手順

このチュートリアルでは、RTL IP をアクセラレーション カーネルとしてパッケージし (`.xo`)、Vitis コア開発キットで使用する方法を説明します。これを達成するため、次の 2 つの方法を使用します。

* [IP/XO をパッケージ](./package_ip.md)
* [RTL Kernel ウィザード](./vitis_ide.md)

> **ヒント:** 既存の RTL モジュールを Vivado IP としてパッケージし、その IP を Vitis カーネル (`.xo`) としてパッケージすることから開始します。それが [IP/XO パッケージ](./package_ip.md) フローです。その後 RTL Kernel ウィザードを使用して RTL カーネルのエレメントを作成し、既存の RTL モジュールをそのフレームワークに合うようにします。それが [RTL Kernel ウィザード](./vitis_ide.md) フローです。[IP/XO パッケージ](./package_ip.md) フローの方がシンプルでより直接的ですが、[RTL Kernel ウィザード](./vitis_ide.md) フローにはより多くのオプションがあります。

RTL カーネルを作成した後、Vitis IDE を使用して、ハードウェア エミュレーションで Vitis アプリケーション プロジェクトをテストします。

* [Vitis IDE プロジェクトでの RTL カーネルの使用](./using_the_rtl_kernel.md)
* [Vivado Design Suite — RTL デザイン](./vivado_ip.md)

</br><hr/>
<p align="center" class="sphinxhide"><b><a href="/README.md">メイン ページに戻る</a></b></p>
<p align="center" class="sphinxhide"><sup>Copyright&copy; 2020 Xilinx</sup></p>

<table>
 <tr>
   <td align="center"><img src="https://japan.xilinx.com/content/dam/xilinx/imgs/press/media-kits/corporate/xilinx-logo.png" width="30%"/><h1>2019.2 Vitis™ アプリケーション アクセラレーション開発フローのチュートリアル</h1><a href="https://github.com/Xilinx/SDAccel-Tutorials/branches/all">SDAccel™ 開発環境 2019.1 チュートリアルを参照</a></td>
 </tr>
 <tr>
 <td align="center"><h1>アクセラレーションした FPGA アプリケーションの最適化: たたみ込みの例</td>
 </tr>
</table>

# 7\. ハードウェアでのアクセラレータの実行

ここまでは、前の演習すべての結果をハードウェア エミュレーション モードで実行して、システムをビルドするためのコンパイル時間を減らしつつ、最適化によってどれくらいパフォーマンスが改善できるかを確認してきました。このセクションでは、前の最適化それぞれをビルドして、Alveo データセンター アクセラレータ カードのハードウェアで実行します。

それぞれの実行が終了するたびに、ホスト アプリケーションから表示されるパフォーマンス データを記録し、セクションの終わりの表に数値を埋めていきます。数値は、場合によって異なることもあります。  
次のデータを記録してください。

* **データ合計**: (フレーム数 x フレーム サイズ) で計算。
* **合計時間**: ハードウェアのタイムライン トレース レポートで測定。公正に比較するため、これにはデータ転送とカーネル実行時間も含まれます。
* **スループット**: 処理されたデータ合計 (MB)/合計時間 (s) で計算。

> **重要:**: この演習の手順では、それぞれハードウェア カーネルをコンパイルするので、終了するのにかなり時間がかかる可能性があります。

## ベースライン アプリケーションのハードウェアでの実行

> **重要**: `design.cfg` の `nk` オプションが 1 に設定されていることを確認します。

次のコマンドを使用して、ハードウェアでベースライン デザインをビルドおよび実行します。実行が終了すると、ホスト アプリケーションがカーネル実行時間とスループット値を表示します。この数値を表に書き込んで、ベンチマーク比較に使用します。

```
make run TARGET=hw STEP=baseline SOLUTION=1
```

表示されるメッセージは、次のようになります。

```
FPGA Time:       701.888 s
FPGA Throughput: 1.48762 MB/s


Processed 7.91 MB in 703.580s (1.48 MBps)

```

## メモリ転送演習のハードウェアでの実行

> **重要**: design.cfg の `nk` オプションが 1 に設定されていることを確認します。

次のコマンドを使用して、ハードウェアで localbuf バージョンのデザインを実行します。

```
make run TARGET=hw STEP=localbuf SOLUTION=1
```

ホスト アプリケーションで表示されるパフォーマンス数値から、実行時間がかなり改善されたことがわかります。

```
FPGA Time:       86.7961 s
FPGA Throughput: 12.0298 MB/s


Processed 7.91 MB in 91.883s (11.36 MBps)

```

## 固定小数点演習のハードウェアでの実行

> **重要**: design.cfg の `nk` オプションが 1 に設定されていることを確認します。

ハードウェアで fixedpoint バージョンのデザインをビルドして実行し、パフォーマンス数値を記録します。

```
make run TARGET=hw STEP=fixedpoint SOLUTION=1
```

```
FPGA Time:       27.2872 s
FPGA Throughput: 38.2649 MB/s


Processed 7.91 MB in 32.290s (32.34 MBps)

```

## データフロー演習のハードウェアでの実行

> **重要**: design.cfg の `nk` オプションが 1 に設定されていることを確認します。

ハードウェアで dataflow バージョンのデザインをビルドして実行し、パフォーマンス数値を記録します。

```
make run TARGET=hw STEP=dataflow SOLUTION=1
```

```
FPGA Time:       3.66991 s
FPGA Throughput: 284.514 MB/s


Processed 7.91 MB in 7.996s (130.58 MBps)

```

### 複数の計算ユニット演習のハードウェアでの実行

ハードウェア ターゲットをビルドする前に、CU 数を 4 に設定する必要があります。これには、`design.cfg` を開いて `nk` オプションを次のように変更します。

```
nk=convolve_fpga:4
```

次のコマンドを使用して、複数の計算ユニット (multi-CU) バージョンのデザインをハードウェアで実行します。

```
make run TARGET=hw STEP=multicu SOLUTION=1
```

ホスト プログラムが終了したら、同様の数値になることがわかるはずです。

```
FPGA Time:       2.35359 s
FPGA Throughput: 443.637 MB/s


Processed 7.91 MB in 7.246s (144.10 MBps)

```

### パフォーマンス表

最終的なパフォーマンスのベンチマーク表は、次のようになります。

| 演習名| Image Size| Number of Frames| Time (Hardware) (s)| Throughput (MBps)
|:----------|:----------|----------:|----------:|----------:
| baseline| 1920x1080| 132| 701.8| 1.48
| localbuf| 1920x1080| 132| 86.8| 12 (8.1x)
| fixed-point data| 1920x1080| 132| 27.3| 38.2 (3.2x)
| dataflow| 1920x1080| 132| 3.6| 284 (7.4x)
| multi-CU| 1920x1080| 132| 2.35| 443 (1.5x)

---------------------------------------


## まとめ

お疲れ様でした！これで、この演習のすべてのモジュールを終了し、標準的な CPU ベースのアプリケーションを FPGA アクセラレーションされたアプリケーションに変換し、Alveo U200 データセンター アクセラレータ カードで実行すると、ほぼ 300 倍のスループットで実行できるようになりました。パフォーマンス目標を設定してから、一連の最適化を使用してその目標を達成しました。

1. ベースの C アプリケーションから Vitis コア開発キット アプリケーションを作成しました。
2. ソフトウェアおよびハードウェア エミュレーション中に生成されるレポートを理解できるようになりました。
3. HLS カーネルのさまざまな最適化方法を確認しました。
4. OpenCL API コマンド キューを順不同で実行するように設定して、パフォーマンスを改善する方法を学びました。
5. カーネルをイネーブルにして、複数 CU で実行するようにしました。
6. HLS データフロー指示子を使用し、それがアプリケーションにどのように影響するかを確認しました。
7. Alveo データセンター アクセラレータ カードで最適化したアプリケーションを実行し、実際にパフォーマンスがどれくらい改善したかを確認しました。</br>

<hr/>
<p align="center"><b><a href="../../docs/vitis-getting-started/README.md">入門コースの初めに戻る</a> &mdash; <a href="./README.md">チュートリアルの初めに戻る</a></b></p>
<p align="center"><sup>Copyright&copy; 2019 Xilinx</sup></p>
